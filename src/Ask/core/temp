import { until } from 'wait-promise'
import qs from 'querystring'

import { isSupportNewLoginWin, openNewLoginWin } from './nativebridge'
import { AppLocalStorage } from './localStorage'
import { Config } from './config'
import { uploadSession, clickVoice, performanceDetected, isWin, H5SendEvent, packagesExamine } from 'utils/helpfunc';

// 与后端约定响应状态,通过判断可知是否由拦截器处理该响应
const SUCCESS_CODE = ['0'] // 响应成功
const AUTHORITY_CODE = ['-1', '10001'] // token失效

// 预置content-type
const contentType = new Map();
contentType.set('json', 'application/json;charset=utf-8');
contentType.set('form', 'application/x-www-form-urlencoded;charset=utf-8;');
contentType.set( 'multipart', 'multipart/form-data;boundary=----WebKitFormBoundarykkrZ5yIY8cr0hdgE');

// 是否正在刷新token
let isRefreshingTocken = false

// 默认的额外参数值
const defaultParam = {
  // 跟后端交互配置项 && 兼容原来的请求方法
  timeout: 5000, // 超时时间
  type: 'json', // conte-type
  withMobile: false, // 是否包括手机?
  withToken: true, // 是否包括token?
  appVersion: '1.4.0',
  apiVersion: '2.1.0', // 接口版本号
  appName: AppLocalStorage.getAppName() || 'KidsPC',
  platform: navigator.platform,
  userAgent: navigator.userAgent,
  accessToken: AppLocalStorage.getOauthToken(),
  headers: {},
  body: {},
  // 为了方便使用的自定义项
  basePrefix: '', // 默认请求前缀
  resFormat: 'data', // 返回数据内容 data: 只返回接口响应的data | origin: 接口响应的所有数据{code,data,message}
  disposePlace: 'inner', // 处理响应异常的地方 inner: 内部处理, outer: 外部处理
  stringifyBody: true, // 是否要把body转为json字符串
}

// 默认的fetch参数 - 仅供参考,不做实际用途
// https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/fetch
const defaultInit = {
  method: 'GET',
  headers: {},
  body: {},
  mode: 'cors', // cors/no-cors/same-origin
  credentials: 'same-origin', // omit/same-origin/include/FederatedCredential/PasswordCredential
  cache: 'default', // default/no-store/reload/no-cache/force-cache/only-if-cached
  redirect: 'follow', // follow/error/manual
  referrer: 'client', // no-referrer/client/url地址,
  referrerPolicy: '', // no-referrer/no-referrer-when-downgrade/origin/origin-when-cross-origin/unsafe-url
  integrity: '', // 请求的subresource integrity值
}

// JOSN转Url参数
const JsonToUrlParams = (data) => {
  return Object.keys(data)
    .map(k => `${encodeURIComponent(k)}=${encodeURIComponent(data[k])}`)
    .join('&')
}

// 响应值转为json
const parseJSON = (response) => {
  return response.json()
}

/**
 * 响应拦截器
 * 因为fetch只有在网络错误的时候reject 所以可以在次使用拦截器做响应状态拦截
 * @param {*} response
 */
const interceptor = (response) => {
  // status 200-299 认为响应成功
  if (response.ok === true) {
    return response
  } else {
    // 返回异常信息
    // 可处理异常status
    throw({
      code: response.status, // 为了让前端处理异常用
      data: null,
      message: '响应失败',
    })
  }
}

// 清除用户登录数据
const removeUserLoginInfo = () => {
  // 清除登录数据
  localStorage.removeItem('user.password')
  localStorage.removeItem('user.mobile')
  localStorage.removeItem('NavIndex')
  localStorage.removeItem('subjectCode')
  localStorage.removeItem('remember-login-password')
  localStorage.removeItem('loginType')
  AppLocalStorage.removeIsLogin()
  AppLocalStorage.removeUserInfo()
  AppLocalStorage.removeTocken()
  if (window.NativeLogin) {
    window.NativeLogin('logout')
  } else if (isSupportNewLoginWin()) {
    openNewLoginWin()
    return
  }
  location.href = '/'
}

// 设置tocken - copy 原來逻辑
const makeTocken = (response) => {
  if (response.code.toString() === '1') {
    isRefreshingTocken = false
    const tockenData = AppLocalStorage.getTocken()
    const newData = Object.assign({}, tockenData, {
      accessToken: response.data.accessToken,
      refreshToken: response.data.refreshToken,
      oauthToken: response.data.oauthToken
    })
    // 更新LocalStorage里的所有Token
    AppLocalStorage.setAccessTocken(response.data.accessToken)
    AppLocalStorage.setRefreshTocken(response.data.refreshToken)
    AppLocalStorage.setOauthToken(response.data.oauthToken)
    const loginType = localStorage.getItem('loginType')
    const basicInfo = AppLocalStorage.getUserInfo()
    if (loginType === '2' || loginType === '3') {
      AppLocalStorage.setUserInfo({
        ...basicInfo,
        password: response.data.accessToken
      })
    }
    return AppLocalStorage.setTocken(newData)
  }
  if (response.code.toString() === '0') {
    removeUserLoginInfo()
  }
  return ''
}

/**
 * token过期,自动刷新token - copy 原來逻辑
 * @param {*} response
 * @param {*} uri
 * @param {*} options
 */
const refreshTocken = () => {
  const refreshUrl = `${Config.apiurl}/api/oauth/refreshToken`
  return fetch(
    refreshUrl,
    Object.assign({}, options('POST', 'form', false, true), {
      body: JsonToUrlParams({
        refresh_token: AppLocalStorage.getTocken().refreshToken
      })
    })
  )
  .then(checkStatus)
  .then(parseJSON)
  .then(res => makeTocken(res))
}

/**
 * 校验权限 用于校验并处理token问题 - copy 原來逻辑
 * @param {*} response
 * @param {*} uri
 * @param {*} options
 */
const authority = (response, url, options) => {
  if (AUTHORITY_CODE.includes(response.code)) {
    const actionFn = new Promise(resolve => resolve())
    let newOptions = options
    // 如果正在刷新token
    if (!isRefreshingTocken) {
      actionFn = refreshTocken().then(() => {
        newOptions.headers.accessToken = AppLocalStorage.getOauthToken()
      })
    }
    isRefreshingTocken = true
    const promise = actionFn
                      .then(() => until(() => !isRefreshingTocken))
                      .then(() => {
                        newOptions.headers.accessToken = AppLocalStorage.getOauthToken()
                      })
    return promise.then(() =>
      fetch(`${url}?access_token=${AppLocalStorage.getTocken().accessToken}`, newOptions)
        .then(checkStatus)
        .then(parseJSON)
      )
  }
  return response
}

/**
 * 请求超时方法
 * @param {*} time
 */
const overtimeFn = (time) => {
  return new Promise((_, reject) => {
    setTimeout(() => {
      reject({
        code: -100, // 为了让前端处理异常用,自定义的约定值
        data: null,
        message: '请求超时'
      })
    }, time)
  })
}

/**
 * 响应后端返回的异常状态
 * 可以在此设置异常消息提醒弹窗 or 其他操作
 * @param {*} res
 */
const responseAbnormality = (res) => {
  const { code } = res
  switch (code) {
    case '11':
      console.log('用户未登录，自动跳转到登录页')
      uploadSession()
      // 移除用户屏幕分辨率的数据统计便是
      localStorage.removeItem('screenAcc')
      sessionStorage.removeItem('REACT_HISTORIES_KEY')
      removeUserLoginInfo()
      break
    default:
      // 异常状态码
      console.error(`[ABNORMALITY CODE] ${code}`) 
  }
}

// 处理fetch的参数
const disposeFetchOptions = (url, method, data, realParam) => {
  let uri = url
  // fetch参数 可参照defaultInit制定实际场景用到的值
  const init = {
    method: method,
    body: { ...realParam.body, },
    headers: {
      Accept: 'application/json',
      'Content-Type': contentType.get(realParam.type),
      ...realParam.headers,
    }
  }
  // 兼容原来的请求方式
  if (realParam.withMobile) {
    init.headers = {
      ...init.headers,
      mobile: AppLocalStorage.getMobile(),
      password: AppLocalStorage.getPassWord(),
    }
  }
  // 兼容原来的请求方式
  if (realParam.withToken) {
    init.headers = {
      ...init.headers,
      accessToken: realParam.accessToken,
      Platform: realParam.platform,
      'App-Name': realParam.appName,
      'App-version': realParam.appVersion,
      'Api-Version': realParam.apiVersion,
      'User-Agent': realParam.userAgent,
    }
  }
  // get/post请求参数位置不一致 可根据实际情况拓展其他请求方式
  switch (method.toUpperCase()) {
    case 'GET':
      uri = `${url}?${JsonToUrlParams(data)}`
      delete init.body
      break
    case 'HEAD':
      delete init.body
      break
    case 'POST':
      const body = { ...init.body, ...data }
      init.body = realParam.stringifyBody ? qs.stringify(body) : body
    default:
      init.body = { ...init.body, ...data }
      break
  }
  return [uri, init]
}

/**
 * fetch 请求封装
 * @param {*} url 请求地址
 * @param {*} data 请求参数 传给后端的具体参数对象
 * @param {*} method 请求方法
 * @param {*} param 额外的参数
 * 
 * // 可按实际需求制定param
 * defaultParam
 * 
 */
const Request = (url = '', data = {}, method = 'GET', param = {}) => {
  if (!url) throw '请求地址不可为空!'
  return new Promise((resolve, reject) => {
    try {
      const realParam = { ...defaultParam, ...param }
      const [uri, init] = disposeFetchOptions(url, method, data, realParam)
      // 先拦截响应信息 - 确认是否正常响应
      // 把响应信息转化为json
      // 校验请求权限
      // 暴露响应信息
      Promise.race([fetch(uri, init), overtimeFn(realParam.timeout)])
        .then(interceptor)
        .then(parseJSON)
        .then(res => authority(res, uri, init))
        .then((result) => {
          // 与后端约定的响应成功状态
          if (realParam.disposePlace === 'inner') {
            // 判断响应的code是否成功
            if (SUCCESS_CODE.includes(result.code)) {
              // console.log(`[RESPONSE SUCCESS]`, result)
              // 判断需要返回的数据内容
              const json = realParam.resFormat === 'origin' ? result : result.data
              resolve(json)
            } else {
              responseAbnormality(result)
              reject(result)
            }
          } else {
            // 设置为outer后resformat会失效
            resolve(result)
          }
        })
        .catch(e => {
          // console.error(`[FETCH ERROR] ${e.message}`)
          reject(e)
        })
    } catch (e) {
      // console.error(`[CATCH ERROR] ${e.message}`)
      reject(e)
    }
  })
}

// 默认暴露出去的方法,根据实际情况拓展
export const get = (url, data, param) => Request(url, data, 'GET', param)
export const post = (url, data, param) => Request(url, data, 'POST', param)

export default Request

/** 
 * 使用示例
 * requst.get(uri, {请求参数}, {额外的参数}).then(res).catch(e)
 * const res = await request.get(uri, data, param) | 需要配合try catch
 */
